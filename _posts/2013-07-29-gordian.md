---
title: Introduction to Gordian
layout: post
---

Now, if you aren't in FRC (or don't know what that is), you can probably stop reading at this point.

Alright, so I've worked pretty hard on a project I started all the way back in October. I'm finally happy with what I have, and from now on I'll be building on the base.

The project is [Gordian](http://team4334.github.io/gordian/). It's a scripting language that runs on Java ME without any kind of dependencies. All you need in order to run a Gordian script is the Java class (or source) files.

### What's it for?
Gordian is designed for running autonomous scripts. It can also be used for any kind of function though. For example, you might want to be able to edit small tasks without re-deploying code. You can do that with Gordian.

### What does it do?
Gordian is a scripting language. The basics:

+ Interpreted
+ Dynamically typed
+ Run directly from Java
+ Methods defined in script and/or in Java
+ No objects, classes, pointers, lambdas, function pointers

The goals:

+ Provide easy, safe syntax for any use
+ Avoid any feature creep and stay stable

I know some of you are asking right now why you wouldn't just use [lua](http://www.lua.org/), specifically [greyhound lua](http://hg.zombiezen.com/greyhound-lua/wiki/Home). I'd say that if you're using C++ **definitely** use lua. Otherwise, lua is a really complex language to run on top of our already crunched-down jvm and squawk. It's pretty difficult to install (I know a lot of programmers in FRC don't have *too* much experience), and much more verbose than most teams need. There's a valid use case for sure, but my point is that Gordian fills a different need (lightweight, simple to install, easy to learn, efficient syntax).

## Using Gordian
Gordian is found [here](https://github.com/Team4334/gordian), and the important part is the `src` folder. You can [clone](http://git-scm.com/book/en/Git-Basics-Getting-a-Git-Repository#Cloning-an-Existing-Repository) the repository yourself, or press `Download ZIP`.

Copy the contents of the `src` folder into your Java FRC project source folder. You now have access to the Gordian classes.

From there, things get interesting. To do basic script running, use the `Gordian` class.

    Gordian.run("Script goes here");

If you don't have a way to get contents of a text file, checkout the `TextFiles` class in [atalibj](https://github.com/Team4334/atalibj/blob/master/src/edu/first/util/TextFiles.java). (Shameless self-promotion)

If you want to do some fancy stuff (which I probably discourage people from doing, considering it probably means your doing things not suited for Gordian), use the `Scope` class.

    Scope s = new Scope();
    s.run("Script goes here");

You can thread the `run` method, and access some useful internals from Gordian in the `Scope` class.

For the even more curious, you can use the `RunningEnvironment` class.

    Scope s = new Scope();
    RunningEnvironment runtime = s.new RunningEnvironment();
    runtime.next("Instructions");
    runtime.next("More Instructions");

This makes it possible to run multiple things inside of the same environment (same access to variables and methods). It also makes it possible to have console-like behaviour, if that's what you want. (I advise not to do this in FRC type stuff - it's pretty technically heavy) An example is [here](https://gist.github.com/joelgallant/6119088).

## The scripts
Gordian follows some pretty basic syntax. It's inspirations are python, bash and java. It kind of looks like a blend of all three.

For a full specification of syntax, visit the [Gordian page](http://team4334.github.io/gordian/#language-specification). Here are the basics:

Everything is separated using newlines or semi-colons, used interchangeably.

Methods are defined like this:

    def foo()
        # Instructions are here
    end
    
or in Java

    new UserMethod("print") {
        public void run(Value[] arguments) {
            System.out.println(arguments[0].getValue());
        }
    }
    
Methods can also return values

    def foo()
        return 13
    end
    
or in Java

    new UserReturningMethod("get") {
        public Object runFor(Value[] arguments) {
            return Double.valueOf(14.3);
        }
    }
    
There are three data types in Gordian, **Numbers**, **Booleans** and **Strings**. They are all inferred.

Numbers are stored as an inferred type between floating point and integer. If `x % 1.0 == 0` is true, it will be an integer. Otherwise it's a 64 bit floating point number.

Variables are created with a value

    x = "Hello World"
    
Empty variables can be created using

    make x

Variables can be deleted using

    del x
    
Note that variables can be shadowed and variable creation and deletion will only affect the *most local* version of the variable.

Control flow:

    if (x == 13 || x == 16)
        print(x + " is awesome")
    else if(x > 16)
        print(x + " sucks")
    else
        # Meh
    end
    
    for(13)
        x++
        print(x)
    end

    while(!isReady())
        wait()
    end

Every method, variable and returning method has a scope. It is only accessible inside of that scope.

    x = 0

    def foo(x)
        # can't access original x, only argument x
        i = 12
        if(true)
            y = 13

            def foo2()
            end
        end
        # can't access y, foo2()
    end

    # can't access i, y, foo2()

Hopefully you can use Gordian in next season's build season, or if you're creative somewhere totally unrelated! Thanks for reading.
